# Ένας οδηγός για την Rholang

Η Rholang είναι μια νέα γλώσσα προγραμματισμού σχεδιασμένη για χρήση σε κατανεμημένα συστήματα. Όπως όλα τα νεογέννητα πράγματα, αυξάνεται και μεταβάλλεται γρήγορα· αυτό το έγγραφο περιγράφει τη σύνταξη που θα χρησιμοποιηθεί στην έκδοση Mercury.

Η Rholang είναι "προσανατολισμένη στη διαδικασία": όλοι οι υπολογισμοί γίνονται με τη μετάδοση μηνυμάτων. Τα μηνύματα μεταβιβάζονται σε "κανάλια", τα οποία μοιάζουν με ουρές μηνυμάτων αλλά συμπεριφέρονται ως σύνολα αντί για ουρές. Η Rholang είναι εντελώς ασύγχρονη, υπό την έννοια ότι ενώ μπορείτε να διαβάσετε ένα μήνυμα από ένα κανάλι και στη συνέχεια να κάνετε κάτι με αυτό, δεν μπορείτε να στείλετε ένα μήνυμα και στη συνέχεια να κάνετε κάτι εφόσον θα έχει ληφθεί --- τουλάχιστον, όχι χωρίς ρητή αναμονή μηνύματος επιβεβαίωσης από τον δέκτη.

## Συμβόλαια, αντανάκλαση και αποστολή δεδομένων

    1 contract @"HelloWorld"(system) = {
    2     system!("print", "Hello, world!")
    3 }

1) Στο Διαδίκτυο, οι διακομιστές έχουν διευθύνσεις IP. Η υπηρεσία ονομάτων τομέα (DNS) χαρτογραφεί αλφαριθμητικές συμβολοσειρές σε αριθμούς, όπως και σε έναν τηλεφωνικό κατάλογο. Αντί να χρησιμοποιεί αριθμούς ή συμβολοσειρές, η Rholang είναι "ανακλαστική": όλα τα κανάλια παίρνουν το όνομα τους από μια σειριακή διαδικασία. Όλες οι σειριοποιήσεις διεργασιών αρχίζουν με ένα `@`. Αυτό το συμβόλαιο ακούει για μηνύματα που αποστέλλονται στο κανάλι που έχει ονομαστεί από τη σειριακή διαδικασία `"HelloWorld"`. Για να είμαστε ακριβείς, λέμε, "Αυτή η σύμβαση ακούει στο όνομα `@"HelloWorld"`."

Ένα συμβόλαιο διακυρήσει ένα API με το οποίο άλλες διαδικασίες μπορούν να αλληλεπιδράσουν μαζί του. Τα συμβόλαια υψηλού επιπέδου έχουν όλα το ίδιο API: έχουν ένα όρισμα, το κανάλι για τη διαδικασία `system`. Η διαδικασία `system` περιέχει τα ονόματα όλων των καναλιών που μπορούν να προκαλέσουν παρενέργειες στον κόμβο. Αυτή είναι μια ολοκληρωμένη διαδικασία που ακούει για μηνύματα που αποτελούνται από ένα όνομα μεθόδου και μερικά ορίσματα.

2) Ο χειριστής θαυμαστικών στέλνει το μήνυμα στα δεξιά του πάνω από το αριστερό του κανάλι. Κάθε μήνυμα είναι μια πλειάδα ονομάτων. Αν στείλουμε μια διαδικασία αντί για ένα όνομα, γίνεται αυτόματα σειριοποίηση σε ένα όνομα.

Σε αυτή την περίπτωση, στέλνουμε ένα μήνυμα που αποτελείται από δύο διαδικασίες, τη συμβολοσειρά `"print"` και τη συμβολοσειρά `"Hello, world!"` Η διαδικασία `system` είναι μια ενσωματωμένη διαδικασία που ακούει για μηνύματα που αποτελούνται από ένα όνομα μεθόδου και μερικά ορίσματα· στην περίπτωση αυτή στέλνει το δεύτερο επιχείρημα στην έξοδο standard.

## Νέα κανάλια, λήψη δεδομένων και μοτίβα

    1 contract @"HelloAgain"(system) = new chan in {
    2     chan!("Hello again, world!") |
    3     for (@text <- chan) system!("print", text)
    4 }

1) Για να δημιουργήσουμε ένα νέο, ιδιωτικό κανάλι, χρησιμοποιούμε την κατασκευή `new ... in`. Καμία άλλη διαδικασία δεν μπορεί να στείλει ή να λάβει μηνύματα μέσω αυτού του καναλιού, εκτός αν κάνουμε ρητή αποστολή αυτού του καναλιού στην άλλη διαδικασία.

2) Στέλνουμε τη διαδικασία string `"Hello again, world!"` πάνω από το νέο κανάλι.

3) Ακούμε στο νέο κανάλι για βρούμε ένα μήνυμα. Η λειτουργία `for` μπλοκάρει μέχρις ότου υπάρχει διαθέσιμο ένα μήνυμα στο κανάλι `chan`.

Η γλώσσα των μοτίβων (επίσης γνωστή ως "spatial types") περιλαμβάνει τη γλώσσα των διαδικασιών και των ονομάτων. Κάθε διαδικασία με ελεύθερες μεταβλητές είναι ένα μοτίβο που ταιριάζει με μια διαδικασία με την ίδια δομή· οι ελεύθερες μεταβλητές δεσμεύονται στις υποεπεξεργασίες σε αυτή τη θέση. Στη γραμμή 3, αναμένουμε μια πλειάδα με ένα στοιχείο. Αυτό το στοιχείο είναι η σειριοποίηση κάποιας διαδικασίας, και επομένως ξεκινά με ένα `@`. Δεδομένου ότι στείλαμε μια συμβολοσειρά στη γραμμή 2, η ελεύθερη μεταβλητή `text` δεσμεύεται σε αυτή τη διαδικασία συμβολοσειράς. Τέλος, η γραμμή 3 προωθεί αυτή τη συμβολοσειρά στη διαδικασία `system ' πρός εκτύπωση.

Αργότερα, θα διερευνήσουμε κάποια ακόμα χαρακτηριστικά των μοτίβων.

## Μεταβλητή κατάσταση, αναπαραγωγή και επιλογή

     1 contract @"CellDemo"(system) = new MakeCell in {
     2     // Δημιουργεί ένα κελί στο οποίο μπορείς να αποθηκεύεις τιμές
     3     contract MakeCell(@init, get, set) = new valueStore in {
     4         valueStore!(init) |
     5         for (@value <= valueStore) {
     6             select {
     7                 ack <- get => valueStore!(value) | ack!(value)
     8                 @newValue, ack <- set => valueStore!(newValue) | ack!()
     9             }
    10         }
    11     } |
    12 
    13     // Χρήση του κελιού.
    14     new myGet, mySet in {
    15         MakeCell(123, *myGet, *mySet) |
    16         new ack in {
    17             myGet!(*ack) |
    18             for (@result <- ack) {
    19                 system!("print", result, *ack) |
    20                 for (_ <- ack) {
    21                     mySet!(456, *ack) |
    22                     for (_ <- ack) {
    23                         myGet!(*ack) |
    24                         for (@result <- ack) {
    25                             system!("print", result)
    26                         }
    27                     }
    28                 }
    29             }
    30         }
    31     }
    32 }
    
1) Δημιουργούμε ένα νέο κανάλι MakeCell και στη συνέχεια το χρησιμοποιούμε στη γραμμή 3 ως το όνομα ενός εσωτερικού συμβολαίου. Καμία διαδικασία εκτός από τον κώδικα μέσα στο συμβόλαιο `@"CellDemo"` δεν μπορεί να την επικαλεστεί.

3) Η σύμβαση `MakeCell` λαμβάνει τρία επιχειρήματα. Το πρώτο επιχείρημα είναι μια διαδικασία, η αρχική τιμή που θα αποθηκευτεί στο κελί. Το δεύτερο και το τρίτο επιχείρημα είναι κανάλια πάνω στα οποία το κελί θα λαμβάνει αιτήματα για να πάρει και να ορίσει την τιμή. Εκείνοι που είναι εξοικειωμένοι με τη C++ μπορούν να σκεφτούν τα κανάλια ως περίπου ισοδύναμα με τους δείκτες με την έννοια ότι ένας δείκτης είναι ένας σειριοποιήσιμος τύπος δεδομένων που υποδηλώνει μια θέση. Ο χειριστής `@` μέσα σε αυτό το πλαίσιο είναι σχεδόν ισοδύναμος με το `&` που υποδηλώνει το pass-by-reference. η μεταβλητή `init` συνδέεται με μια διαδικασία αντί για ένα κανάλι. Στην C++, για να μετατρέψουμε έναν δείκτη σε μια αναφορά, χρησιμοποιούμαι τον τελεστή `*`. ομοίως, στη Rholang για τη μετατροπή ενός καναλιού σε μια διαδικασία, χρησιμοποιούμε τον χειριστή `*`. Δεδομένου ότι μπορούμε να στείλουμε μόνο διεργασίες μέσω ενός καναλιού, ο χειριστής `*` χρησιμοποιείται πολύ συχνά· δείτε τις ζυγές γραμμές στο παράδειγμα χρήσης.

Για να αποθηκεύσουμε την τιμή, δημιουργούμε ένα νέο κανάλι. Αυτό το κανάλι θα έχει πάνω του το πολύ ένα μήνυμα το οποίο θα περιέχει την τρέχουσα τιμή του κελιού.

4) Πριν από αυτή τη γραμμή, δεν υπάρχουν μηνύματα στο κανάλι `valueStore`. Αφού στείλουμε την αρχική τιμή, είναι η μοναδική τιμή σε αυτό το κανάλι.

5) Παράλληλα με την γραμμή 4, προσπαθούμε να διαβάσουμε από το `valueStore`. Το διπλό βέλος μας λέει ότι μόλις λάβουμε ένα μήνυμα σε αυτό το κανάλι, θα πρέπει να δημιουργήσουμε ένα αντίγραφο της διαδικασίας αμέσως μετά το `for` και να προσπαθήσουμε να ξανά διαβάσουμε αυτό το κανάλι αμέσως.

Μόλις ένα μήνυμα γίνει διαθέσιμο, δεσμεύουμε τη μεταβλητή `value` στη διαδικασία του μηνύματος.

6-8) Η λέξη `select` στη γραμμή 6 σημαίνει ότι μόνο ένα από τα κλαδιά στις γραμμές 7 ή 8 θα μπορέσει να προχωρήσει. Σε αυτό το σημείο, δεν υπάρχει μήνυμα που να περιμένει στο κανάλι `valueStore`.

Αν υπάρχει μήνυμα στο κανάλι `get`, τότε το κλαδί στη γραμμή 7 μπορεί να τρέξει. Η μεταβλητή `ack` συνδέεται με το μήνυμα και παράλληλα συμβαίνουν δύο πράγματα: η τιμή που διαβάζουμε ξανά στέλνετε στο `valueStore` και στο κανάλι `ack`.

Τα μηνύματα είναι πλειάδες ονομάτων. Όλα τα μηνύματα που έχουμε δει μέχρι τώρα είχαν την arity 1, αλλά εδώ στη γραμμή 8, περιμένουμε ένα μήνυμα της arity 2. Το πρώτο μέρος του μοτίβου συνδέει τη μεταβλητή `newValue` στο πρώτο μέρος του μηνύματος, ενώ το δεύτερο μέρος του μοτίβου δεσμεύει τη μεταβλητή `ack` σε ένα κανάλι. Αντί να στείλουμε την `value` στο `valueStore` όπως κάναμε στη γραμμή 7, στέλνουμε `newValue`.

Επίσης στη γραμμή 8, στέλνουμε ένα μήνυμα arity 0. Στο παράδειγμα χρήσης, οι γραμμές 20 και 22 χρησιμοποιούν μια υπογράμμιση για να λάβουν αυτό το άδειο μήνυμα και να το απορρίψουν.

9) Σε αυτό το σημείο, υπάρχει και πάλι ακριβώς ένα μήνυμα στο κανάλι `valueStore`.

13-31) Ο κώδικας χρήσης επιδεικνύει τη δημιουργία ενός κελιού, την εκχώρηση της αρχικής τιμής 123, τη λήψη και την εκτύπωση αυτής της τιμής, τη ρύθμιση της τιμής σε 456, και έπειτα την λήψη και την εκτύπωση αυτής της τιμής.

Σημειώστε τα βαθιά στρώματα της επανάκλησης. Η Rholang σχεδιάστηκε έτσι ώστε να κάνει φυσική την έκφραση των παράλληλων υπολογισμών· ως εκ τούτου, σε άλλες γλώσσες πρέπει να καταστούν σαφείς οι εξαρτήσεις δεδομένων που εμπεριέχονται στην αλληλουχία.

## Εναλλαγή

    1 contract @"IterateDemo"(system) = new chan in {
    2     [1,2,3].iterate(chan) |
    3     for (@num, ack << chan) system!("print", num, *ack)
    4 }

2) Οι αγκύλες υποδεικνύουν μια λίστα. Οι λίστες είναι μεταβλητές, ενώ οι πλειάδες, που υποδεικνύονται με παρενθέσεις, δεν είναι. Ορισμένες διαδικασίες, όπως αυτές που υποστηρίζονται από αντικείμενα της Java, έχουν μεθόδους· εδώ η μέθοδος `iterate` γίνεται επίκληση με ένα κανάλι για εναλλαγή.

3) Ο χειριστής `<<` υποδεικνύει "διαδοχική αποστολή", ή με άλλα λόγια, ότι τα μηνύματα από το chan χρειάζονται επιβεβαίωση πριν από την αποστολή νέων μηνυμάτων.

Η μέθοδος `print` της διαδικασίας του συστήματος μπορεί να πάρει ένα ή δύο ορίσματα. Στην περίπτωση δύο παραμέτρων, το δεύτερο όρισμα είναι ένα κανάλι στο οποίο θα αποσταλεί ένα μήνυμα επιβεβαίωσης μόλις ολοκληρωθεί η εκτύπωση. Η μέθοδος `iterate` θα λάβει αυτή την επιβεβαίωση και θα στείλει το επόμενο μήνυμα. Μόλις τελειώσει η λίστα, η γραμμή 3 θα εξελιχθεί στη διαδικασία `Nil` που δεν κάνει τίποτα και θα συλλεχθεί στα σκουπίδια.

## Ταιριάσματα μοτίβου και παράμετροι rest

     1 contract @"CoatCheckDemo"(system) = new MakeCoatCheck in {
     2     contract MakeCoatCheck(ret) = {
     3         new (portIn, portOut):iopair, table in {
     4             ret!(*portOut) |
     5             for (@method, ack, ...@rest <= portIn) {
     6                 match method {
     7                     case "new" => match rest {
     8                         case (initialValue) => new ticket in {
     9                             ack!(*ticket) |
    10                             @(*ticket | *table)!(initialValue)
    11                         }            
    12                     }
    13                     case "get" => match rest {
    14                         case (ticket) => {
    15                             for (@value <! @(*ticket | *table)) {
    16                                 ack!(value)
    17                             }
    18                         }
    19                     }
    20                     case "set" => match rest {
    21                         case (store, @newValue) => {
    22                             for (_ <- @(*ticket | *table)) {
    23                                 @(*ticket | *table)!(newValue) |
    24                                 ack!()
    25                             }
    26                         }
    27                     }
    28                 }
    29             }
    30         }
    31     } |
    32 
    33     // Χρήση
    34     new ret in {
    35         MakeCoatCheck(ret) |
    36         for (cc <- ret) {
    37             // Δημιουργεί ένα νέο κελί με αρχική τιμή 0
    38             cc!("new", *ret, 0) |
    39             for (ticket <- ret) {
    40                 // Ορίζει το κελί σε 1
    41                 cc!("set", *ret, *ticket, 1) |
    42                 for (ack <- ret) {
    43                     // Διαβάζει την τιμή
    44                     cc!("get", *ret, *ticket) |
    45                     for (@storedValue <- ret) {
    46                         // Εκτυπώνει 1
    47                         system!("print", storedValue)
    48                     }
    49                 }
    50             }
    51         }
    52     }
    53 }

2) Ένα μοτίβο σχεδιασμού, που χρησιμοποιείται παραπάνω στο συμβόλαιο MakeCell, είναι να λαμβάνει από τον καλούντα ένα κανάλι για κάθε διαφορετική λειτουργικότητα που μια διαδικασία παρέχει. Ένας προγραμματιστής αντικειμενοστραφούς γλώσσας μπορεί να πει ότι η MakeCell απαιτεί από τον καλούντα να παρέχει ένα κανάλι για κάθε μέθοδο. Τα ταιριάσματα επιχειρούνται με τη σειρά που εμφανίζονται στον κώδικα· αν δεν συμβαίνει κανένα ταίριασμα, το μπλοκ `match` ορίζεται στη διαδικασία `Nil`.

3) Το MakeCoatCheck χρησιμοποιεί μια πιο αντικειμενοστραφή προσέγγιση. Η κατασκευή `(in, out):iopair` μας επιτρέπει να δημιουργήσουμε ένα συζευγμένο ζευγάρι καναλιών. Πρόκειται για σφάλμα τύπου αποστολής μηνύματος μέσω του καναλιού `in` ή για λήψης μηνύματος μέσω του καναλιού `out`. Ωστόσο, κάθε μήνυμα που αποστέλλεται μέσω του καναλιού `out` μπορεί να ληφθεί μέσω του καναλιού `in`. Αυτό μας επιτρέπει να επιστρέψουμε το κανάλι `out` στο οποίο μπορούμε να κάνουμε "κλήσεις μεθόδου" χωρίς να επιτρέψουμε σε άλλες διαδικασίες να παρεμποδίζουν αιτήματα που προορίζονται για τη διαδικασία μας.

Το νέο κανάλι `table` θα χρησιμοποιηθεί για τη δημιουργία καναλιών για εσωτερική χρήση.

5) Εδώ διαβιβάσαμε επανειλημμένα μηνύματα με arity μεγαλύτερη ή ίση με δύο. Η μεταβλητή `method` συνδέεται με το πρώτο όρισμα· περιμένουμε μια συμβολοσειρά που ονομάζει τη μέθοδο, ακριβώς όπως και η διαδικασία του συστήματος. Η μεταβλητή `ack` δεσμεύεται σε ένα κανάλι στο οποίο θα στείλουμε οποιοδήποτε αποτέλεσμα της κλήσης μεθόδου. Η μεταβλητή `rest` συνδέεται με μια πλειάδα που περιέχει το υπόλοιπο μέρος των μηνυμάτων.

6) Η κατασκευή `match ... case` μας επιτρέπει να ταιριάξουμε το μοτίβο για τη δομή μιας διαδικασίας. Αυτό το χρησιμοποιούμε για να κάνουμε αποστολή μηνυμάτων.

7-12) Εάν η `method` είναι η συμβολοσειρά `"new"`, τότε υποθέτουμε στη γραμμή 8 ότι η `rest` θα είναι μια πλειάδα με ένα στοιχείο, την αρχική τιμή. Δημιουργούμε ένα κανάλι `ticket` και το επιστρέφουμε χρησιμοποιώντας το κανάλι `ack`. Επίσης, συνδυάζουμε τις διαδικασίες `*ticket` με το `*table` σε μια νέα διαδικασία και στη συνέχεια από αυτά παράγουμε ένα όνομα καναλιού. Δεδομένου ότι μόνο εμείς έχουμε πρόσβαση στο `table`, μόνο εμείς μπορούμε να χειριστούμε τα δεδομένα που είναι αποθηκευμένα σε κανάλια που έχουν κατασκευαστεί με αυτόν τον τρόπο. Το κανάλι `ticket` συμπεριφέρεται σαν ένα εξαργυρώσιμο εισιτήριο για ένα ελεγχόμενο coat και το κανάλι `@(*ticket | *table)` είναι η καταχώρηση πίνακα που υποδεικνύεται από αυτό το κλειδί.

13-19) Εάν η `method` είναι η συμβολοσειρά `"get"`, τότε υποθέτουμε οτι στη γραμμή 14 η `rest` θα είναι μια πλειάδα με ένα στοιχείο, το συγκεκριμένο εισιτήριο για το αντικείμενο που θα λάβει. Ο χειριστής `<!` διαβάζει μια τιμή από τον πίνακα και το επαναφέρει αμέσως· αυτό είναι,

    for (y <! x) { P }

είναι συντακτική ομορφιά για

    for (y <- x) { x!(*y) | P }.

20-27) Εάν η `method` είναι η συμβολοσειρά `"set"`, τότε υποθέτουμε ότι στη γραμμή 21 η `rest` θα είναι μια πλειάδα με δύο στοιχεία: το κλειδί και τη νέα τιμή. Η γραμμή 22 απομακρύνει την τρέχουσα τιμή σε αυτό το εισιτήριο, η γραμμή 23 στέλνει τη νέα τιμή και η γραμμή 24 σηματοδοτεί ότι έχει τελειώσει.

## Διαχείριση σφαλμάτων

     1 for (@info, ret, err <- channel) {
     2     // Είτε επέστρεψε ενα αποτέλεσμα στην ret ή ένα μήνημα σφάλματος στην err
     3 } |
     4 select {
     5     result <- ret => {
     6         // Αποτέλεσμα διαδικασίας
     7     }
     8     // Μηνήματα στην err που δεν ανήκουν σε αυτό το μοτίβο
     9     // δεν λαμβάνονται εδω
    10     @"TypeError", msg <- err => {
    11         // Διαχείρηση σφάλματος τύπου δεδομένων
    12     }
    13 }

1-3) Μπορούμε να καθορίσουμε πολλαπλά κανάλια στα οποία τα δεδομένα μπορούν να σταλούν πίσω σε έναν πελάτη.

4) Σε αυτό το πλαίσιο, η `select` συμπεριφέρεται σαν την `try` σε άλλες γλώσσες. Μόνο μία από τις παραλαβές στις γραμμές 5 και 10 θα προχωρήσει· αγωνίζονται για να δουν ποιος παίρνει πρώτα ένα μήνυμα. Εάν οι γραμμές 1-3 έχουν αμετάβλητο ότι είτε ένα αποτέλεσμα στέλνεται στην `ret` είτε ένα σφάλμα στην `err`, τότε δεν θα υπάρξει αγώνας. Εάν, από την άλλη πλευρά, θέλουμε να στείλουμε τόσο αποτέλεσμα όσο και σφάλμα, θα πρέπει να χρησιμοποιήσουμε την `for`:

    for (@info, ret, err <- channel) {
        // Είτε επέστρεψε ενα αποτέλεσμα στην ret ή ενα μήνυμα σφάλματος στην err
    } |
    for(result <- ret) {
        // Αποτέλεσμα διαδικασίας
    } |
    for(@"TypeError", msg <- err) {
        // Διαχείρηση σφάλματος τύπου δεδομένων
    }

10) Το μοτίβο εδώ είναι πιο περίπλοκο από αυτά που ειδαμε προηγουμένος. Εδώ, καθορίζουμε ότι θέλουμε μόνο μηνύματα με δύο ονόματα και το πρώτο όνομα θα πρέπει να είναι η σειριοποίηση της συμβολοσειράς `"TypeError"`. Εάν είναι κάτι άλλο, αυτό το κλαδί δεν θα συνεχιστεί.

## Φιλόσοφοι που δειπνούν και αδιέξοδο

     1 new north, south, knife, fork in {
     2     north!(knife) |
     3     south!(fork) |
     4     for (knf <- north) for (frk <- south) {
     5         philosopher1!(knf, frk)
     6     } |
     7     for (frk <- south) for (knf <- north) {
     8         philosopher2!(knf, frk)
     9     }
    10 }

Το πρόβλημα δείπνου των φιλοσόφων έχει δύο φιλοσόφους που μοιράζονται μόνο ένα σύνολο μαχαιροπήρουνων. Ο Philosopher1 κάθεται στην ανατολική πλευρά του τραπεζιού ενώ ο Philosopher2 κάθεται δυτικά. Κάθε ένας χρειάζεται ένα μαχαίρι και ένα πιρούνι για να φάει. Ο καθένας αρνείται να παραιτηθεί από ένα σκεύος μέχρι να χρησιμοποιήσει και τα δύο για να πάρει μια δαγκωματιά. Αν και οι δύο φιλόσοφοι πάνε να πάρουν πρώτα το σκεύος στα δεξιά τους, και οι δύο θα λιμοκτονίσουν: ο Philosopher1 παίρνει το μαχαίρι, ο Philosopher2 παίρνει το πιρούνι και κανένας απο τους δύο δεν τα ξανα αφήνει.

Ακολουθεί ο τρόπος επίλυσης του προβλήματος:

     1 new north, south, knife, spoon in {
     2     north!(knife) |
     3     south!(spoon) |
     4     for (knf <- north; spn <- south) {
     5         philosopher1!(knf, spn)
     6     } |
     7     for (spn <- south; knf <- north) {
     8         philosopher2!(knf, spn)
     9     }
    10 }

4, 7) Ο χειριστής ένωσης, σημειωμένος με ερωτηματικό `;`, δηλώνει ότι η συνέχιση πρέπει να προχωρήσει μόνο εάν υπάρχει διαθέσιμο ένα μήνυμα σε καθένα από τα κανάλια ταυτόχρονα, αποτρέποντας το παραπάνω αδιέξοδο.

## Ενσωματωμένοι τύποι δεδομένων, μόνιμες αποστολές, λογικές συνδέσεις και φιλτράρισμα

Έχουμε δει ότι τα μοτίβα που μπορούμε να χρησιμοποιήσουμε στήν κατασκευή `match` ή στην κατασκευή `for` περιλαμβάνουν διαδικασίες με ελεύθερες μεταβλητές. Μπορούμε επίσης να χρησιμοποιήσουμε μοτίβα που περιγράφουν ενσωματωμένες διαδικασίες. Το μοτίβο `Integer` περιγράφει όλους τους 32-bit υπογεγραμμένους ακέραιους· ομοίως για τα `Double`, `String` και `Boolean`.

Μπορούμε να συνδυάσουμε μοτίβα χρησιμοποιώντας τους λογικούς συνδετήρες AND, OR, και NOT, που γράφωνται ως `&&`, `||`, και `~`, αντίστοιχα.

    for (@(x && Integer) <- y) { P }

Αυτή η διαδικασία δεσμεύει μια μεταβλητή διαδικασίας `x` στο μήνυμα που ελήφθη στην `y`, αλλά επίσης επιμένει ότι η `x` είναι ένας ακέραιος αριθμός.

Υπάρχει ένα αμερικανικό αίνιγμα που λέει: "Πώς φτιάχνουμε δεκαπέντε σέντς σε ψιλά όταν το ένα νόμισμα δεν είναι τάληρο και το άλλο δεν είναι δεκάρα;" Ένα τάληρο αξίζει πέντε λεπτά και μια δεκάρα αξίζει δέκα. Ας υποθέσουμε ότι έχουμε τα ακόλουθα μηνύματα να αποστέλονται στο `coins`, και κωδικοποιούν τα διαθέσιμα είδη αμερικανικών νομισμάτων αξίας μικρότερης των δεκαπέντε σέντς:

    coins!!(1) | coin!!(5) | coin!!(10)

Ο χειριστής `!!` σημαίνει ότι τα μηνύματα πρέπει να παραμένουν στο κανάλι μόνιμα και να μην καταναλώνονται όταν λαμβάνονται από μια κατασκευή `for`.

   new x in { x!!("Hi there!") | for (msg <= x) { system!("print", msg) } }

Η παραπάνω διαδικασία θα εκτυπώσει "Hi there!" για όσο διάστημα λειτουργεί η εικονική μηχανή.

Μπορούμε να κωδικοποιήσουμε το αίνιγμα ως

    for (@(x && ~5) <- coins; @(y && ~10) <- coins if x+y == 15) {
        system!("print", (x, y))
    }

Το πρώτο μοτίβο, `@(x && ~5)`, θα ταιριάζει με οποιοδήποτε μήνυμα στο `coins` που δεν είναι 5 και δεσμεύει την `x` σε αυτό. Ομοίως, το δεύτερο μοτίβο `@(y && ~10)` θα ταιριάζει με οποιοδήποτε μήνυμα στο `coins` που δεν είναι το 10 και θα δεσμεύσει το `y` σε αυτό. Η ρήτρα `if` σε μια κατασκευή `for` επιτρέπει μόνο τον αγώνα να συνεχιστεί εάν ο τύπος στα δεξιά του αξιολογείται σε `true`· σε αυτή την περίπτωση, τίποτα δεν θα εκτυπωθεί εκτός εαν το σύνολο των τιμών είναι 15.

Η απάντηση στο αίνιγμα είναι "Μια δεκάρα και ένα τάληρο", αφού μια δεκάρα δεν είναι τάληρο και ένα τάληρο δεν είναι δεκάρα. Η μεταβλητή `x` θα δεσμευτεί στο 10 και η μεταβλητή `y` θα δεσμευτεί στο 5 και θα εκτυπωθεί το `(10, 5)`.

## Ασφαλή σχέδια μοτίβου

Σε αυτή την ενότητα περιγράφουμε διάφορα σχέδια μοτίβου. Αυτά τα μοτίβα είναι προσαρμοσμένα από το [_A PictureBook of Secure Cooperation_](http://erights.org/talks/efun/SecurityPictureBook.pdf)  του Marc Stiegler.

### Facets

Στο συμβόλαιο MakeCell, ο πελάτης παρέχει δύο κανάλια, ένα για να πάρει την τιμή και ένα για να την ορίσει. Αν ο πελάτης περάσει μόνο το κανάλι `get` σε μια άλλη διαδικασία, αυτή η διαδικασία έχει στην πραγματικότητα μια προβολή μόνο για ανάγνωση του κελιού.

Τα κανάλια όπως το `get` και το `set` ονομάζονται "facets" της διαδικασίας. Ενσωματώνουν την εξουσία για να εκτελέσουν τη δράση. Εάν το κανάλι `set` είναι δημόσιο κανάλι όπως το`@"Foo"`, τότε όποιος μπορεί να μάθει ή ακόμα και να μαντέψει τη συμβολοσειρά `"Foo"` έχει την εξουσία να ρυθμίσει την τιμή του κελιού. Από την άλλη πλευρά, αν το κανάλι `set` δημιουργήθηκε με τον διαχειριστή `new`, τότε δεν υπάρχει τρόπος για οποιαδήποτε άλλη διαδικασία να κατασκευάσει το κανάλι `set`· πρέπει να μεταβιβαστεί απευθείας σε μια διαδικασία, προκειμένου η διαδικασία να τη χρησιμοποιήσει.

Σημειώστε ότι αν το `get` και το `set` δεν δημιουργούνται ως μισά του iopairs, τότε η κατοχή αυτών των καναλιών είναι επίσης εξουσιοδοτημένη να παρεμποδίζει μηνύματα που αποστέλλονται στο κελί:

    for (ret <- get) { P } | 
    for (ret <- get) { Q } | 
    get!(*ack)

Αυτός ο όρος έχει δύο διαδικασίες που ακούν στο κανάλι `get` και μόνο ένα μήνυμα που στέλνεται στο `get`. Μόνο μία από τις δύο διαδικασίες θα είναι σε θέση να λάβει το μήνυμα.

Με τη λήψη καναλιών από τον πελάτη για λήψη και ρύθμιση, το συμβόλαιο MakeCell αφήνει τις αποφάσεις σχετικά με το πόσο δημόσια είναι αυτά τα κανάλια στον πελάτη. Το συμβόλαιο MakeCellFactory, από την άλλη πλευρά, κατασκευάζει τα δικά του κανάλια και τα επιστρέφει στον πελάτη, έτσι ώστε να είναι σε θέση να επιβάλει εγγυήσεις ιδιωτικότητας.

### Εξασθένηση των μεταφορέων

Στο συμβόλαιο MakeCellFactory, υπάρχει μόνο ένα κανάλι και τα μηνύματα αποστέλλονται εσωτερικά. Για να έχουμε το ίδιο αποτέλεσμα ως ενα facet που μόνο για ανάγνωση, μπορούμε να δημιουργήσουμε μια διαδικασία προώθησης που απλά αγνοεί τα μηνύματα που δεν θέλει να προωθήσει. Το παρακάτω συμβόλαιο διαβιβάζει μόνο τη μέθοδο "get".

    contract MakeGetForwarder(target, ret) = {
        new (portIn, portOut):iopair in {
            ret!(*portOut) |
            for (@method, ...@rest <= portIn) {
                method match {
                    case "get" => target!(method, ...rest)
                }
            }
        }
    }

### Ανάκληση

Μπορούμε να εφαρμόσουμε την ανάκληση δημιουργώντας έναν προωθητή με έναν διακόπτη kill.

     1 contract MakeRevokableForwarder(target, ret) = {
     2     new (portIn, portOut):iopair, kill, forwardFlag in {
     3         ret!(*portOut, *kill) |
     4         forwardFlag!(true) |
     5         for (...@rest <= portIn) {
     6             for (@status <! forwardFlag) {
     7                 if (status) {
     8                     target!(rest)
     9                 } else {
    10                     Nil
    11                 }
    12             }
    13         } |
    14         for (_ <- kill; _ <- forwardFlag) {
    15             forwardFlag!(false)
    16         }
    17     }
    18 }

2) Δημιουργούμε ένα iopair για την αποστολή μεθόδων και ένα κανάλι `forwardFlag` για να αποθηκεύουμε το αν θα προωθήσουμε μηνύματα.

3) Επιστρέφουμε το κανάλι στο οποίο οι πελάτες στέλνουν αιτήματα και το κανάλι στο οποίο θα αποσταλεί το σήμα kill.

4) Καθορίσαμε την αρχική κατάσταση του `forwardFlag` σε true.

5-13) Διαβάζουμε σε μια αυθαίρετη πλειάδα τμημάτων μηνυμάτων και παίρνουμε την αξία της σημαίας. Αν η σημαία είναι αληθής, προωθούμε την πλειάδα μηνυμάτων στο `target`.

14-15) Εάν ένα μήνυμα έχει ποτέ σταλεί στο κανάλι `kill`, ορίζουμε το 'forwardFlag' σε false, το οποίο σταματά την προώθηση μηνυμάτων.

### Σύνθεση

Συνδυάζοντας έναν εξασθενητικό προωθητή με ένα ανακλητό προωθητή, παίρνουμε και τα δύο χαρακτηριστικά:

    new ret in {
        MakeGetForwarder(target, *ret) |
        for (@getOnly, kill <- ret) {
            MakeRevokableForwarder(getOnly, *ret) |
            for (@revokableGetOnly <- ret) {
                // δώσε το revokableGetOnly αντί για το target
                // hang στην kill για να γίνει αργότερα ανάκληση
            }
        }
    }

### Πρωοθητής σύνδεσης

Ένας πρωοθητής σύνδεσης μπορεί να καταγράψει όλα τα μηνύματα που έχουν σταλεί σε ένα κανάλι, στέλνοντας τα σε ένα δεύτερο κανάλι.

    contract MakeLoggingForwarder(target, logger, ret) = {
        new (portIn, portOut):iopair in {
            ret!(*portOut) |
            for (...@rest <= portIn) {
                target!(...rest) |
                logger!(...rest)
            }
        }
    }

### Υπευθηνότητα

Ας υποθέσουμε ότι η Alice έχει ένα κανάλι και θα ήθελε να καταγράψει την πρόσβαση του Bob σε αυτό. Ο Bob θα ήθελε να μεταβιβάσει τη χρήση αυτού του καναλιού στην Carol και να καταγράψει την πρόσβασή της. Κάθε συμβαλλόμενο μέρος είναι ελεύθερο να κατασκευάσει το δικό του προωθητή καταγραφής σχετικά με το κανάλι που έχει λάβει. Η Alice θα θέσει τον Bob υπεύθυνο για ότι κάνει η Carol.

### Σφράγισμα και αποσφράγισμα

     1 contract MakeSealerUnsealer(ret) =  {
     2     new (sealerIn, sealerOut):iopair,
     3         (unsealerIn, unsealerOut):iopair,
     4         mapRet in {
     5 
     6         ret!(*sealerOut, *unsealerOut) |
     7         MakeCoatCheck(mapRet) |
     8         for (cc <- mapRet) {
     9             for (@value, ret <= sealerIn) {
    10                 cc!("new", *ret, value)
    11             } |
    12             for (ticket, ret <= unsealerIn) {
    13                 cc!("get", *ret, *ticket)
    14             }
    15         }
    16     }
    17 }

Ένα ζεύγος σφραγίσματος/αποσφραγίσματος παρέχει την ίδια λειτουργικότητα με τα δημόσια κλειδιά, αλλά χωρίς κρυπτογραφία. Είναι απλώς μια εξασθένηση του ελέγχου που περιγράφεται παραπάνω. Αυτό το σχέδιο μοτίβου μπορεί να χρησιμοποιηθεί για να υπογράψει κάτι για λογαριασμό του χρήστη. Στον οδηγό για το blockchain στη Rholang, θα δούμε ότι λειτουργεί ακόμη και στο blockchain επειδή δεν υπάρχουν μυστικά προς αποθήκευση, μόνο τα μη πλαστογραφήσιμα ονόματα που πρέπει να παραμείνουν μη προσβάσιμα.

### Προσοσχή στην αποστολή εξασθενητών

Μια βασική αρχή που πρέπει να θυμάστε με τις διαδικασίες του RChain είναι αυτή που είναι παρόμοια με τις πιο παραδοσιακές εφαρμογές ιστού: οποιοσδήποτε κώδικας στέλνετε σε κάποιον άλλον μπορεί να αποσυναρμολογηθεί. Από τα τέλη της δεκαετίας του 1990, όταν έγινε εφικτή η αγορά των πραγμάτων μέσω του διαδικτύου, [υπήρξαν πλατφόρμες ηλεκτρονικού εμπορίου](https://blog.detectify.com/2016/11/17/7-most-common-e-commerce-security-mistakes/) όπου η πλατφόρμα βασίστηκε στα προγράμματα περιήγησης των χρηστών για να στείλει τη σωστή τιμή του στοιχείου πίσω σε αυτήν. Οι συγγραφείς δεν σκέφτηκαν ότι ο χρήστης θα ανοίγε τα εργαλεία προγραμματιστών και θα άλλαζε την τιμή πριν να στείλει πίσω. Ο σωστός τρόπος για να δημιουργήσετε μια πλατφόρμα ηλεκτρονικού εμπορίου είναι να αποθηκεύσετε τις τιμές στο διακομιστή και να τις ελέγξετε εκεί.

Ας υποθέσουμε ότι ο Bob είναι πρόθυμος να εκτελέσει κάποιο κώδικα για την Alice· έχει ένα συμβόλαιο που λέει κάτι σαν "Πάρτε μια διαδικασία από αυτό το κανάλι και τρέξτε τη".

    for (@P <- x) { P }

Αυτό είναι ακριβώς σαν ένα πρόγραμμα περιήγησης ιστού να είναι πρόθυμο να εκτελέσει τον κώδικα JavaScript που παίρνει από έναν ιστότοπο. Αν η Alice στείλει στον Bob έναν εξασθενητικό μεταφορέα, ο Bob μπορεί να χρησιμοποιήσει τις παραγωγές πρότυπων αντιστοιχίας της Rholang για να διαλύσει τη διαδικασία και να αποκτήσει πρόσβαση στον υποκείμενο πόρο. Αντ 'αυτού, όπως στο παράδειγμα ηλεκτρονικού εμπορίου, η Alice πρέπει να στείλει μόνο κώδικα που διαβιβάζει τα αιτήματα στις δικές της διαδικασίες και να κάνει την εξασθένηση εκεί.

## Συμπέρασμα

Το RChain είναι μια γλώσσα σχεδιασμένη για χρήση σε blockchain, αλλά δεν έχουμε αναφέρει τίποτα για τους κόμβους, τα namespaces, τα πορτοφόλια, τα Rev και το Phlogiston, τη δομή του δικτύου ή τον Casper. Ένα προσεχές έγγραφο θα εξετάσει όλα αυτά τα θέματα και πολλά άλλα.

Ελπίζουμε ότι τα παραπάνω παραδείγματα προκαλούν την επιθυμία να γράψουμε περισσότερο κώδικα και να επιδείξουμε την ευκολία έκφρασης των ταυτόχρονων σχεδίων.
